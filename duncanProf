# ANSI color codes \o/
RS="\[\033[0m\]"    # reset
HC="\[\033[1m\]"    # hicolor
UL="\[\033[4m\]"    # underline
INV="\[\033[7m\]"   # inverse background and foreground
FBLK="\[\033[30m\]" # foreground black
FRED="\[\033[31m\]" # foreground red
FGRN="\[\033[32m\]" # foreground green
FYEL="\[\033[33m\]" # foreground yellow
FBLE="\[\033[34m\]" # foreground blue
FMAG="\[\033[35m\]" # foreground magenta
FCYN="\[\033[36m\]" # foreground cyan
FWHT="\[\033[37m\]" # foreground white
BBLK="\[\033[40m\]" # background black
BRED="\[\033[41m\]" # background red
BGRN="\[\033[42m\]" # background green
BYEL="\[\033[43m\]" # background yellow
BBLE="\[\033[44m\]" # background blue
BMAG="\[\033[45m\]" # background magenta
BCYN="\[\033[46m\]" # background cyan
BWHT="\[\033[47m\]" # background white

# My prompt
# PS1="\`if [ \$? = 0 ]; then echo $FCYN; else echo $FRED; fi \`[\w]\\$ $RS"

# so that the git stuff works right
# source /etc/bash_completion.d/git

parse_git_branch() {
	git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'
}

TERM_WIDTH=0
HORZ_LINE=""

function myPrompt {
RET=$?
MYCLR=""

#set colors according to output success, store for later
if [ $RET != 0 ]; then
	MYCLR=$FRED
else
	MYCLR=$FCYN
fi

#if the window changes width, change the line separator
if [ $TERM_WIDTH != $COLUMNS ]; then
	TERM_WIDTH=$COLUMNS
	HORZ_LINE=""

	for (( c=1; c<=$COLUMNS; c++)); do
		HORZ_LINE+="_"
	done
fi

# print the line separator
echo $HORZ_LINE


#check to see if we're in a git directory
parse_git_branch() {
     git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'
}


#set the actual prompt
IN_REPO=$(parse_git_branch)

if [ "$IN_REPO" != "" ]; then
	PS1="$MYCLR[\w]$HC$FGRN$(parse_git_branch)$RS$MYCLR\\$ $RS"
else
	PS1="$MYCLR[\w]\\$ $RS"
fi
}
# end function myPrompt

PROMPT_COMMAND=myPrompt



# to make it obvious this file was called in the first place
echo duncanProf loaded
